## 프로퍼티 접근

객체의 프로퍼티에 접근하는 방법에는 두 가지가 있습니다.
1. **마침표 표기법** (**Dot Notation**): `object.propertyKey`
2. **대괄호 표기법** (**Bracket Notation**): `object['propertyKey']`

프로퍼티 키가 자바스크립트 **식별자 네이밍 규칙을 준수**한다면 두 가지 방법 모두 사용할 수 있습니다.
```javascript
var person = {
  name: 'Lee',
  'last-name': 'Park'
};

// 마침표 표기법
console.log(person.name); // 'Lee'

// 대괄호 표기법 (키를 문자열로 지정)
console.log(person['name']); // 'Lee'
```

객체의 존재하지 않는 프로퍼티에 접근하면 에러가 아니라 undefined를 반환합니다.
```javascript
var person = {
  name: 'Lee',
}

console.log(person.age) // undefined
```

#### 대괄호 표기법은 다음과 같은 경우에 반드시 사용해야 합니다.
- 프로퍼티 키가 식별자 네이밍 규칙을 따르지 않을 때(예: 하이픈 `-`, 공백 포함)
- 프로퍼티 키가 변수에 저장된 값이거나, 동적으로 결정해야 할 때
```javascript
var person = {
  'last-name': 'Kim',
  1: 10
};

// 네이밍 규칙을 따르지 않으므로 대괄호 표기법만 가능
console.log(person['last-name']); // 'Kim'
// console.log(person.last-name); // 에러 발생: person.last 에서 name 을 빼려는 시도로 해석

// 프로퍼티 키가 숫자인 경우 따옴표를 생략할 수 있음
console.log(person[1]); // 10
```

### `person[name]`과 `person['name']`의 차이

대괄호 내부에 따옴표가 없으면 자바스크립트 엔진은 이를 **문자열이 아닌 변수로 해석**합니다.
```javascript
console.log(person['name']); // 'name'이라는 문자열 키를 찾음
// console.log(person[name]);   // 'name'이라는 변수를 찾음. 해당 변수가 선언되지 않았다면 ReferenceError 발생
```


### `last-name`이 Node.js와 브라우저에서 다르게 동작하는 이유'

`preson[last-name]`처럼 따옴표 없이 사용하면, 자바스크립트는 `last`라는 변수에서 `name`이라는 변수를 빼는(`-`) 연산으로 해석합니다.
- **Node.js 환경**: `last`나 `name`이라는 변수가 선언되어 있지 않다면 바로 `ReferenceError`가 발생하며 코드가 중단됩니다.
- **브라우저 환경**: 전역 객체 `window`에 기본적으로 `name`이라는 프로퍼티(`window.name`)가 존재하며, 기본값은 빈 문자열(`''`)입니다. 따라서 `last`는 `undefined`이고 `name`은 `''`이므로 `undefined-''`연산이 실행되어 결과는 `NaN`이 됩니다. 결국 `person[NaN]`에 접근하게 되어 최종적으로 `undefined`가 반환됩니다.


## 프로퍼티 값 변경, 생성, 삭제

### 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신됩니다.
```javascript
var person = {
  name: 'Lee',
}

person.name = 'Kim';
console.log(person.name); // { name: "Kim" }
```

### 프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되고 값이 할당됩니다.
```javascript
var person = {
  name: 'Lee',
}

person.age = 20;

console.log(person.age); // 20
```

### 프로퍼티 삭제

`delete` 연산자를 사용하여 객체의 프로퍼티를 삭제할 수 있습니다. 존재하지 않는 프로퍼티를 삭제하려고 해도 에러 없이 안전하게 무시됩니다.

```javascript
var person = {
  name: 'Lee',
}

person.age = 20;

delete person.age; // 삭제
delete person.address; // 무시

console.log(person); // { name: "Lee" }
```

## ES6 객체 리터럴 확장 기능

ES6부터는 객체 리터럴은 더 간결하고 유연하게 사용할 수 있는 기능들이 추가되었습니다.

### 프로퍼티 축약 표현 (Property Shorthand)

프로퍼티 **키 이름과 값으로 사용될 변수 이름이 동일**할 경우, 하나로 축약해서 표현할 수 있습니다.
```javascript
var x = 1, y = 2;

// ES5
var obj_es5 = {
  x: x,
  y: y
};

// ES6
var obj_es6 = {
  x,
  y
};

console.log(obj_es6); // { x: 1, y: 2 }
```

### 계산된 프로퍼티 이름

객체 리터럴 내부에서도 대괄호 `[...]`를 사용하여 프로퍼티 키를 동적으로 생성할 수 있습니다.
```javascript
var prefix = 'prop';
var i = 0;

// ES5
var obj_es5 = {};
obj_es5[prefix + '-' + ++i] = i;
obj_es5[prefix + '-' + ++i] = i;


// ES6
var obj_es6 = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i
};

console.log(obj_es6); // { prop-1: 1, prop-2: 2 }
```



### 메서드 축약 표현 (Method Shorthand)

메서드를 정의할 때 `: function` 키워드를 생략하고 더 간결하게 작성할 수 있습니다.

```javascript
// ES5
var obj_es5 = {
  name: 'Lee',
  sayHi: function() {
    console.log('Hi! ' + this.name);
  }
};

// ES6
var obj_es6 = {
  name: 'Lee',
  sayHi() {
    console.log('Hi! ' + this.name);
  }
};

obj_es6.sayHi(); // 'Hi! Lee'
```

