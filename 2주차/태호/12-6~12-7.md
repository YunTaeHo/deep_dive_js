## 참조에 의한 전달과 외부 상태의 변경

자바스크립트에서 **원시 타입**(**primitve type**)은 **값에 의한 전달**, **객체 타입**(**object type**)**은 참조에 의한 전달** 방식으로 동작합니다.
함수에 인수를 전달할 때도 이 방식은 그대로 적용됩니다.
- 원시 타입 인수는 함수 내에서 값을 변경해도 외부 변수에 영향을 주지 않습니다. (값의 복사복이 전달)
- 객체 타입 인수는 함수 내에서 프로퍼티를 변경하면 외부 객체도 함께 변경됩니다. (참조값(메모리 주소)이 전달)
```javascript
// 원시값(num)과 객체(person)를 매개변수로 받는 함수
function changeValue(num, person) {
  // 함수 내부에서 매개변수의 값을 변경
  num = num + 10;
  person.name = 'Kim';

  console.log(`함수 내부: num = ${num}, person.name = ${person.name}`);
}

// 원본 변수 선언
let originalNum = 10;
let originalPerson = { name: 'Lee' };

console.log(`호출 전: originalNum = ${originalNum}, originalPerson.name = ${originalPerson.name}`);
// 출력: 호출 전: originalNum = 10, originalPerson.name = Lee

// 함수 호출
changeValue(originalNum, originalPerson);
// 출력: 함수 내부: num = 20, person.name = Kim

console.log(`호출 후: originalNum = ${originalNum}, originalPerson.name = ${originalPerson.name}`);
// 출력: 호출 후: originalNum = 10, originalPerson.name = Kim
```
위 예시처럼, 함수가 외부 상태(`originalPerson` 객체)를 직접 변경하면 상태 변화를 추적하기 어려워 코드의 복잡성이 증가하고 가독성을 해치는 원인이 됩니다.
마찬가지로 **부수 효과**(**side effect**)가 발생합니다.

이 문제를 해결하기 위한 방법은 다음과 같습니다:
1. **불변 객체**(**Immutable Object**): 객체를 직접 수정하지 않고, 객체의 깊은 복사(deep copy)를 통해 새로운 객체를 생성하여 상태를 변경합니다.
2. **옵저버 패턴**(**Observer Pattern**): 객체를 공유하는 곳들에 상태 변경 사실을 통지하여 대처하게 만듭니다.

이러한 부수 효과를 최소화하려는 프로그래밍 패러다임이 **함수형 프로그래밍**이며, 외부 상태를 변경하지 않고 의존하지 않는 함수를 **순수 함수**(**Pure Function**)라고 합니다.


## 함수의 다양한 형태

함수는 사용 목적에 따라 다양한 형태로 정의하고 호출할 수 있습니다.


### 즉시 실행 함수(IIFE, Immediately Invoked Function Expression)


함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라고 합니다. 
단 한번만 호출되며 다시 호출할 수 없습니다.

일반적으로 익명 함수를 사용하며, 함수 리터럴을 그룹 연산자 `(...)`로 감야 합니다.
```javascript
// 가장 일반적인 형태
(function() {
  console.log('이 함수는 즉시 실행됩니다.');
}());

// 그룹 연산자의 위치가 달라도 가능
(function() {
  console.log('이 함수도 즉시 실행됩니다.');
})();

// SyntaxError: 함수 선언문 뒤에 ()를 붙일 수 없음
/*
function() {
  console.log('문법 오류!');
}();
*/

// SyntaxError: 그룹 연산자로 감싸지 않은 기명 함수도 마찬가지
/*
function foo() {
  console.log('문법 오류!');
}();
*/
```
자바스크립트 엔진이 `function` 키워드를 함수 선언문으로 해석하여 발생하는 오류이므로,
그룹 연산자로 감싸 함수 리터럴 표현식으로 인식하도록 해야합니다.

즉시 실행 함수는 값을 반환하거나 인수를 전달받을 수도 있습니다.
```javascript
// 값을 반환하는 IIFE
var res = (function() {
  var a = 3;
  var b = 5;
  return a * b;
}());

console.log(res); // 15

// 인수를 전달받는 IIFE
res = (function (a, b){
  return a * b;
}(3, 5));

console.log(res); // 15
```
즉시 실행 함수의 가장 큰 장점은 **독립적인 스코프를 생성**한다는 점입니다.
전역 스코프에 변수를 추가하지 않으므로 변수나 함수 이름의 충돌을 방지할 수 있습니다.

### 재귀 함수 (Recursive Function)

함수가 자기 자신을 호출하는 것을 **재귀 호출**이라 하며, 이러한 함수를 **재귀 함수**라고 합니다.
재귀 함수를 사용하면 반복되는 처리를 반복문 없이 구현할 수 있습니다.

```javascript
// 팩토리얼 구현 (재귀 함수)
// n! = n * (n-1) * ... * 1
function factorial(n) {
  // 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춤
  if (n <= 1) return 1;

  // 자기 자신을 호출 (재귀 호출)
  return n * factorial(n - 1);
}

console.log(factorial(5)); // 5 * 4 * 3 * 2 * 1 = 120
```
재귀 함수에는 반드시 재귀 호출을 멈출 **탈출 조건**이 있어야 합니다.
탈출 조건이 없으면 함수가 무한히 호출되어 **스택 오버플로우**(**Stack Overflow**) 에러가 발생합니다.

대부분의 재귀 함수는 반복문으로 구현 가능합니다.
```javascript
// 팩토리얼 구현 (for문)
function factorialFor(n) {
  let result = 1;
  for (let i = n; i >= 1; i--) {
    result *= i;
  }
  return result;
}

console.log(factorialFor(5)); // 120
```
재귀 함수는 반복문보다 코드가 직관적일 수 있지만, 함수 호출에 따른 메모리 및 성능 부담이 있으므로 신중하게 사용해야 합니다.
트리 순회 등 깊이를 예측하기 어려운 문제를 해결할 때 유용합니다.


### 중첩 함수 (Nested Function)

함수 내부에 정의된 함수를 **중첩 함수** 또는 **내부 함수**라고 합니다.
중첩 함수를 포함하는 바깥 함수는 **외부 함수**라 부릅니다.

중첩 함수는 외부 함수 내부에서만 호출할 수 있으며, 보통 외부 함수를 돕는 **헬퍼 함수**(**helper function**) 역할을 합니다.
```javascript
function outer() {
  var x = 1;

  // 중첩 함수
  function inner() {
    var y = 2;
    // 중첩 함수는 외부 함수의 변수(x)에 접근 가능
    console.log(x + y); // 3
  }

  inner();
}

outer();
```
ES6부터 `if`, `for`문과 같은 코드 블록 내에서도 함수를 선언할 수 있지만, 호이스팅으로 인해 혼란이 발생할 수 있어 권장되지 않습니다.
중첩 함수는 **스코프**와 **클로저** 개념과 깊은 관련이 있습니다.

### 콜백 함수 (Callback Function)

함수는 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 **콜백 함수**라고 하며, 콜백 함수를 전달받는 함수를 **고차 함수**(**Higher-Order Function**)라고 합니다.

고차 함수는 전달받은 콜백 함수의 로직을 사용하여 유연하게 동작을 변경할 수 있습니다.
```javascript
// 고차 함수: n번 반복하며 콜백 함수 f를 호출
function repeat(n, f) {
  for(var i = 0; i < n; i++){
    f(i); // 매번 콜백 함수를 실행
  }
}

// 콜백 함수 1: 모든 숫자를 로그로 출력
var logAll = function(i) {
  console.log(i);
};

// 콜백 함수 2: 홀수만 로그로 출력
var logOdds = function(i) {
  if(i % 2) console.log(i);
};

// 고차 함수에 콜백 함수를 전달하여 호출
repeat(5, logAll); // 0 1 2 3 4
repeat(5, logOdds); // 1 3
```
고차 함수는 콜백 함수의 **호출 시점**을 결정하고, 콜백 함수에 **인수를 전달**할 수 있습니다.
중첩 함수가 고정된 헬퍼 함수라면, 콜백 함수는 교체 가능한 유연한 헬퍼 함수입니다.

콜백 함수는 한 번만 사용될 경우 보통 **익명 함수 리터럴** 형태로 전달됩니다.
```javascript
repeat(5, function(i) {
  if(i % 2) console.log(i);
});
```
콜백 함수는 자바스크립트에서 매우 중요하며, 다음과 같은 다양한 곳에서 핵심적인 역할을 합니다.
- **비동기 처리**: `setTimeout`, `setInterval`, `Promise`, `async/await` 등 비동기 작업이 완료되었을 때 실행될 로직을 전달합니다.
```javascript
// 1초 후에 콜백 함수가 실행됨
setTimeout(function() {
  console.log('1초가 지났습니다.');
}, 1000);
```
- **DOM 이벤트 핸들러**: 사용자의 클릭, 입력 등의 이벤트가 발생했을 때 실행될 함수를 등록합니다.
```javascript
// 'myButton'을 클릭하면 콜백 함수가 실행됨
document.getElementById('myButton').addEventListener('click', function() {
  alert('버튼이 클릭되었습니다!');
});
```
- **배열 고차 함수**: `forEach`, `map`, `filter`, `reduce` 등 배열을 순회하며 각 요소에 대한 처리를 콜백 함수로 전달합니다.
```javascript
const numbers = [1, 2, 3, 4, 5];
// 각 요소를 제곱하는 콜백 함수 전달
const squaredNumbers = numbers.map(function(num) {
  return num * num;
});
console.log(squaredNumbers); // [1, 4, 9, 16, 25]
```


## 순수 함수와 비순수 함수

순수 함수는 **부수 효과**(**side effect**)**가 없다**는 기본 전체 외에도 다음과 같은 중요한 특징을 가집니다.

### 순수 함수

순수 함수는 오직 **입력받은 매개변수에만 의존**하여 결과를 반환합니다. 
외부의 어떤 상태나 데이터에도 영향을 받지 않기 때문에, 동일한 인수를 전달하면 몇 번을 호출하더라도 항상 같은 결과를 보장합니다.
이 특성 덕분에 함수의 동작을 예측하기가 매우 쉬워집니다.
```javascript
// 순수 함수
function add(a, b) {
  return a + b;
}

add(2, 3); // 언제, 어디서 호출하든 항상 5
add(2, 3); // 여전히 5
```

순수 함수는 전달받은 인수(특히 객체나 배열)를 직접 수정하지 않고, **데이터의 새로운 버전을 만들어 반환**함으로써 **불변성**(**Immutability**)을 지킵니다.
이는 원본 데이터를 훼손하지 않아 프로그램 전체의 안정성을 크게 높여줍니다.
```javascript
const person = { name: 'Kim', age: 30 };

// person 객체를 직접 바꾸지 않고 새로운 객체를 반환하는 순수 함수
function celebrateBirthday(p) {
  return { ...p, age: p.age + 1 }; // 전개 구문을 사용해 새로운 객체 생성
}

const newPerson = celebrateBirthday(person);

console.log(person);     // { name: 'Kim', age: 30 } -> 원본은 불변
console.log(newPerson);  // { name: 'Kim', age: 31 } -> 새로운 객체가 반환됨
```
따라서 순수 함수는 매개변수에만 의존하여 항상 같은 결과를 내놓고, 외부 상태나 원본 데이터를 변경하지 않으므로 매우 안정적이고 예측 가능합니다.

### 비순수 함수

**비순수 함수**란, 함수가 실행되면서 자신의 범위(scope) 바깥에 있는 **외부 상태를 변경**하거나, 외부 상태에 의존하여 **실행 결과가 달라지는 함수**를 말합니다.
이러한 외부 상태와의 상호작용을 **부수 효과**(**side effect**)가 발생하게 됩니다.

함수 바깥에 있는 변수의 값을 직접 읽거나 수정하는 것은 가장 대표적인 부수 효과입니다.
아래 `increase` 함수는 매개변수 `n`을 사용하지 않고 외부의 `count` 변수를 직접 변경하므로 비순수 함수입니다.
```javascript
var count = 0;

function increase(n) {
  return ++count;
}

increase(count);
console.log(count);

increase(count);
console.log(count);
```

객체를 인수로 전달받아 그 객체의 프로퍼티를 직접 수정하는 것 또한 외부 상태를 변경하는 행위이므로 비순수 함수입니다.
```javascript
let user = { name: 'Kim' }; // 외부 상태

function changeName(person, newName) {
  person.name = newName; // 참조를 통해 외부 객체를 직접 수정함
}

changeName(user, 'Lee');
console.log(user); // { name: 'Lee' }
```

### 문제점과 올바른 사용법

함수가 외부 상태를 직접 변경하면 **상태 변화를 추적하기 매우 어려워집니다**. 
코드의 규모가 커질수록어떤 함수가 상태를 변경했는지 파악하기 힘들어지고, 이는 예기치 않은 버그의 원인이 됩니다.

따라서 좋은 프로그래밍 습관은 다음과 같습니다:
1. **부수 효과는 최대한 억제합니다**. 가능하면 순수 함수로 핵심 로직을 작성하여 예측 가능하고 테스트하기 쉬운 코드를 만듭니다.
2. **부수 효과는 필요한 곳에만 사용합니다**. DOM 조작, 서버 통신(API 호출), 파일 저장 등 외부 세계와 반드시 상호작용해야 하는 부분에서만 제한적으로 사용하고, 해당 코드를 명확히 분리하여 관리하는 것이 좋습니다.

