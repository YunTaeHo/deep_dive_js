## 논리 연산자를 사용한 단축 평가 (Short-circuit Evaluation)

논리합(`||`)또는 논리곱(`&&`) 연산자는 연산 과정 중 결과가 확정되면 나머지 평가 과정을 생략하고 그 값을 그대로 반환합니다.
이를 **단축 평가**라고 합니다. 이 특징 덕분에 단순히 `true`/`false`를 반환하는 것을 넘어, 특정 값을 선택하거나 코드의 흐름을
제어하는 데 유용하게 사용됩니다.
- **논리곱**(`&&`): 왼쪽 피연산자부터 평가하여 **Falsy** 값을 만나면 즉시 그 값을 반환하고, 모두 **Truthy**하다면 마지막 피연산자의 값을 반환합니다.
- **논리합**(`||`): 왼쪽 피연산자부터 평가하여 **Truthy** 값을 만나면 즉시 그 값을 반환하고, 모두 **Falsy**하다면 마지막 피연산자의 값을 반환합니다.

```javascript
// && 연산자: 왼쪽이 true이면 오른쪽을 평가
'Cat' && 'Dog' // "Dog"
false && 'Dog' // false

// || 연산자: 왼쪽이 true이면 즉시 왼쪽 값을 반환
'Cat' || 'Dog' // "Cat"
false || 'Dog' // "Dog"
```

### if문을 단축 평가로 대체하기

단축 평가는 간단한 `if`문을 대체하여 코드를 더 간결하게 만들 수 있습니다.
- `&&`: 조건이 **Truthy**일 때 무언가를 실행하고 싶을 때 사용합니다.
```javascript
const isLoggedIn = true;

// if문 사용
if (isLoggedIn) {
  console.log('로그인 되었습니다.');
}

// && 단축 평가 사용
isLoggedIn && console.log('로그인 되었습니다.');
```
- `||`: 조건이 **Falsy**일 때 무언가를 실행하고 싶을 때 사용합니다.
```javascript
const isNotLoggedIn = false;

// if문 사용
if (!isNotLoggedIn) {
  console.log('로그인이 필요합니다.');
}

// || 단축 평가 사용 (조건을 반대로 생각)
isNotLoggedIn || console.log('로그인이 필요합니다.');
```

if...else문은 삼항 연산자로 대체 가능합니다.
```javascript
const num = 10;
const result = (num % 2 === 0) ? '짝수' : '홀수'; // '짝수'
```

## 단축 평가의 유용한 패턴들


###  객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때

객체를 가리킬 것으로 예상되는 변수가 실제로는 `null`이나 `undefined`일 때 그 프로퍼티에 접근하면 **TypeError**가 발생하여 프로그램이
멈춥니다. 단축 평가는 이 에러를 방지하는 데 매우 유용합니다.
```javascript
let user = null;

// user.name; // TypeError: Cannot read properties of null (reading 'name')

// 단축 평가로 에러 방지
// user가 Falsy(null)이므로 user.name은 평가되지 않고 null이 반환됨
const name = user && user.name;
console.log(name); // null
```


### 함수 매개변수에 기본값을 설정할 때

함수 호출 시 인수를 전달하지 않으면 매개변수는 `undefined`가 됩니다. 이때 단축 평가를 사용하면 손쉽게 기본값을 설정할 수 있습니다.
```javascript
// ES6 이전의 기본값 설정 방식
function greet(name) {
  // name이 Falsy(undefined)이면 'Guest'를 할당
  const userName = name || 'Guest';
  console.log(`Hello, ${userName}!`);
}

greet(); // "Hello, Guest!"
greet('Kim'); // "Hello, Kim!"
```

## 최근에 업데이트 된 연산자 (ES11/2020)

### 옵셔널 체이닝 연산자(`?.`)

옵셔널 체이닝(`?.`)은 `&&` 연산자의 단점을 보완한 연산자입니다. 좌항의 피연산자가 `null`**또는** `undefined`인 경우에만 평가를 중단하고
`undefined`를 반환합니다. 그 외의 Falsy 값(`0`, `''`, `NaN` 등)은 유효한 값으로 취급하여 평가를 계속 진행합니다.
```javascript
// && 연산자의 문제점: ''(빈 문자열)은 Falsy라서 뒤를 평가하지 않음
const userWithEmptyName = { name: '' };
const nameFromAnd = userWithEmptyName && userWithEmptyName.name;
console.log(nameFromAnd); // '' (이 경우엔 괜찮아 보이지만...)

let str = '';
let length = str && str.length; // ''는 falsy. length는 ''
console.log(length); // ''

// 옵셔널 체이닝: null과 undefined가 아니면 평가를 이어감
let str2 = '';
let length2 = str2?.length; // ''는 null/undefined가 아니므로 length 프로퍼티에 접근
console.log(length2); // 0
```


### null 병합 연산자(`??`)

null 병합 연산자(`??`)는 `||`연산자의 단점을 보완합니다. 좌항의 피연산자가 `null` **또는** `undefined`일 경우에만 우항의 값을 반환하고,
그 외의 Falsy 값들은 그대로 반환합니다. 변수에 기본값을 설정할 경우 매우 유용합니다.
```javascript
// || 연산자의 문제점: 0은 Falsy라서 의도치 않게 기본값이 할당될 수 있음
const count = 0;
const finalCount = count || 10;
console.log(finalCount); // 10 (원래 의도는 0이었는데!)

// null 병합 연산자: null과 undefined에만 반응
const count2 = 0;
const finalCount2 = count2 ?? 10;
console.log(finalCount2); // 0 (0은 유효한 값이므로 그대로 반환)

const nullValue = null;
const finalValue = nullValue ?? '기본값';
console.log(finalValue); // "기본값"
```




