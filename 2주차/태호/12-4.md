## 함수 정의 (Function Definition)

함수 정의란 함수를 호출하기 전에 **인수를 전달받을 매개변수**,**실행할 문들**, 그리고 **반환할 값**을 미리 지정하는 것을 말합니다.
이렇게 정의된 함수는 자바스크립트 엔진에 의해 평가되어 하나의 **함수 객체**(**Function Ojbect**)가 됩니다.

### 변수는 선언, 함수는 정의

두 키워드의 역할을 구분하는 표현입니다.
- **변수 선언**(`var`, `let`, `const`): `var myVar;`와 같이 특정 이름을 가진 변수가 존재한다는 것을 엔진에 알리는 행위입니다. 이름만 알려줄 뿐, 그 안에 어떤 코드가 들어있는지에 대한 정보는 없습니다.
- **함수 정의**(`function`): `function myFunc() {...}`와 같이 함수의 이름뿐만 아니라, **어떤 매개변수를 받고 어떤 코드 블록을 실행할지 그 내용**(**구현체**)**까지 모두 지정**하는 행위입니다. 즉, '선언'의 의미를 포함하는 더 포괄적인 정의라는 개념을 내포합니다.

함수는 정의하는 방식에 크게 4가지가 있습니다.
- **함수 선언문** (**Function Declaration**)
```javascript
function add(x, y) {
  return x + y;
}
```

- **함수 표현식** (**Function Expression**)
```javascript
var add = function add(x, y) {
  return x + y;
}
```

- **Function 생성자 함수** (**Function Constructor**)
```javascript
var add = new Function('x', 'y', 'return x + y');
```

- **화살표 함수** (**Arrow Function, ES6**)
```javascript
var add = (x, y) => x + y;
```


## 함수 선언문 (Function Declaration)

함수 선언문은 `function` 키워드로 시작하며, 함수 리터럴과 형태가 동일하지만 몇 가지 중요한 차이점이 있습니다.

```javascript
// 함수 선언문
function add(x, y) {
  return x + y;
}

console.dir(add); // f add(x, y)
console.log(add(2, 5)); // 7
```
- **함수 이름 생략 불가**: 함수 선언문은 함수 이름을 생략할 수 없습니다. 이는 함수 이름이 자바스크립트 엔진이 암묵적으로 생성하는 식별자로 사용되기 때문입니다.
- **표현식이 아닌 문**: 함수 선언문은 그 자체로 하나의 문(statement)입니다. 따라서 완료 값으로 `undefined`를 가집니다.

원칙적으로 표현식이 아닌 문은 변수에 할당할 수 없습니다.
하지만 아래 코드처럼 함수 선언문처럼 보이는 코드가 변수에 할당되는 경우가 있습니다.
```javascript
// 이는 함수 선언문이 아니라, 변수에 '기명 함수 리터럴'을 할당한 함수 표현식입니다.
var add = function add(x, y) {
  return x + y;
}
```
자바스크립트 엔진은 코드를 해석할 때 문맥에 따라 `function` 키워드를 다르게 해석합니다. 마치 `{}`가 코드 블록으로 쓰일 때와 객체 리터럴로 쓰일 때가 다른 것과 같습니다.
이처럼 코드의 형태가 중의적일 수 있어 내부 동작에 차이가 발생합니다.
```javascript
// 1. 함수 선언문
function foo() { console.log('foo'); }
foo(); // 'foo' 호출 성공

// 2. (그룹 연산자 내의) 기명 함수 표현식
(function bar() { console.log('bar'); });
bar(); // ReferenceError: bar is not defined
```
`foo`가 호출될 수 있는 이유는 자바스크립트 엔진이 **함수 선언문을 해석하여 함수 객체를 생성하고, 함수 이름과 동일한 이름의 식별자**(`foo`)**를 암묵적으로 생성하여 거기에 함수 객체를 할당**하기 때문입니다.

결론적으로, 우리는 **함수 이름으로 함수를 호출하는 것이 아니라, 함수 객체를 가리키는 식별자로 호출하는 것**입니다. 
함수 선언문의 경우, 엔진이 식별자를 자동으로 만들어주기 때문에 마치 함수 이름으로 호출하는 것처럼 보일 뿐입니다.


## 함수 표현식 (Fumnction Expression)

자바스크립트의 함수 **일급 객체**(**First-Class Object**)입니다. 일급 객체란 값처럼 자유롭게 사용할 수 있는 객체를 의미하며, 다음과 같은 특징을 가집니다.
- 변수에 할당할 수 있다.
- 다른 함수의 인수로 전달할 수 있다.
- 다른 함수의 반환값이 될 수 있다.
- 객체의 프로퍼티 값이 될 수 있다.

함수 표현식은 이러한 일급 객체의 특성을 이용하여 **함수 리터럴로 생성한 함수 객체를 변수에 할당**하는 방식으로 함수를 정의합니다.
```javascript
// 익명 함수 리터럴을 변수 add에 할당
var add = function(x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
```
함수 표현식의 함수 리터럴은 이름을 생략한 **익명 함수**(**anonymouse function**)을 사용하는 것이 일반적입니다.
이름을 붙이더라도(기명 함수 표현식), 해당 이름은 함수 몸체 내부에서 재귀 호출 등의 용도로만 사용할 수 있으며 함수 외부에서도 접근이 불가능합니다.

```javascript
// 기명 함수 표현식 예시
var factorial = function fact(n) {
  if (n <= 1) return 1;
  // 함수 이름 'fact'는 함수 몸체 내부에서 재귀 호출에 사용 가능
  return n * fact(n - 1);
};

console.log(factorial(5)); // 120
// console.log(fact(5)); // ReferenceError: fact is not defined (외부에서는 호출 불가)
```

## 함수 생성 시점과 함수 호이스팅

함수 선언문과 함수 표현식은 **함수 객체가 생성되는 시점**이 다릅니다.
```javascript
// 함수 호이스팅: 함수 선언문은 런타임 이전에 이미 생성됨
console.dir(add); // f add(x, y)
console.log(add(2, 5)); // 7

// 변수 호이스팅: 함수 표현식의 변수는 undefined로 초기화됨
console.dir(sub); // undefined
// console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
}
```
- **함수 선언문과 함수 호이스팅**: 함수 선언문은 코드가 순차적으로 실행되는 **런타임 이전에** 자바스크립 엔진에 의해 먼저 해석되고 실행됩니다.
이 과정에서 함수 객체가 생성되고, 함수 이름과 동일한 식별자에 할당까지 완료됩니다. 이를 **함수 호이스팅**(**Function Hoisting**)이라고 합니다.
`var` 키워드를 사용한 변수 호이스팅이 `undefined`로 초기화되는 것과 달리, 함수 호이스팅은 **함수 객체로 완전히 초기화**되기 때문에 선언문 이전에 호출이 가능합니다.
- **함수 표현식과 변수 호이스팅**: 함수 표현식은 변수에 함수 리터럴을 할당하는 문입니다. 따라서 **변수 호이스팅**의 규칙을 따릅니다.
런타임 이전에 `var sub;` 선언부만 끌어올려져 `undefined`로 초기화되고, 실제 할당(`sub = function...`)은 코드가 해당 라인에 도달했을 때 실행됩니다.
따라서 할당문 이전에 `sub`를 호출하면 `undefined`를 함수처럼 호출하려는 시도가 되어 `TypeError`가 발생합니다.

함수 호이스팅은 "함수를 호출하기 전에 반드시 선언해야 한다"는 기본적인 규칙을 무시하는 것처럼 보여 코드의 흐름을 예측하기 어렵게 만들 수 있습니다.
이러한 이유로 JSON을 창안한 더글라스 크락포드 등 많은 개발자들이 **함수 선언문 대신 함수 표현식을 사용할 것을 권장**합니다.

## Function 생성자 함수

자바스크립트가 기본으로 제공하는 빌트인 함수인 `Function` 생성자에 매개변수 목록과 함수 몸체를 문자열로 전달하여 함수 객체를 생성할 수 있습니다.
```javascript
var add = new Function('x', 'y', 'return x + y');

console.log(add(2, 5)); // 7
```
하지만 이 방식은 **일반적으로 권장되지 않으며**, 함수 선언문이나 표현식으로 생성한 함수와 다르게 동작하는 경우가 있습니다.
가장 큰 차이점은 **클로저**(**Closure**)**를 생성하지 않는다**는 점입니다.
```javascript
// add1: 함수 표현식을 사용하여 클로저 생성 (정상 동작)
var add1 = (function () {
  var a = 10;
  return function (x, y) {
    return x + y + a; // 상위 스코프의 변수 'a'를 참조
  };
}());

console.log(add1(1, 2)); // 13

// add2: Function 생성자를 사용하여 클로저 생성 실패
var add2 = (function() {
  var a = 10;
  // Function 생성자로 만든 함수는 상위 스코프가 아닌 전역 스코프를 참조함
  return new Function('x', 'y', 'return x + y + a');
}());

// console.log(add2(1, 2)); // ReferenceError: a is not defined
```
`Function` 생성자로 만든 함수는 자신을 생성한 함수의 지역 변수에 접근할 수없기 때문에 클로저의 이점을 활용할 수 없습니다.

## 화살표 함수 (Arrow Function)

ES6에서 도입된 화살표 함수는 `function` 키워드 대신 화살표(`=>`)를 사용하여  더 간결하게 함수를 정의할 수 있습니다.
화살표 함수는 **항상 익명 함수**로 정의합니다.
```javascript
// 화살표 함수
const add = (x , y) => x + y;
console.log(add(2, 5))
```
화살표 함수는 기존 함수의 단축 표현만을 위해 디자인된 것은 아니며, 내부 동작 방식에도 중요한 차이가 있습니다.
- **생성자 함수로 사용 불가**: `new` 키워드와 함께 사용할 수 없습니다.
- **`this` 바인딩 방식이 다름**: 자신만의 `this`를 갖지 않고, 상위 스코프의 `this`를 그대로 물려받습니다.
- `property` **프로퍼티가 없음**
- `arguments` **객체를 생성하지 않음**

이러한 차이점들로 인해 화살표 함수는 기존의 함수 선언문이나 표현식을 완전히 대체하지는 않으며, 상황에 맞게 사용해야 합니다.