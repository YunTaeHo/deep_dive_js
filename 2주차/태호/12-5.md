## 함수 호출 (Function Call)

함수는 **함수를 가리키는 식별자**와 한 쌍의 소괄호인 **함수 호출 연산자**`()`를 사용해 호출합니다.
함수 호출연산자 내에는 0개 이상의 인수를 쉼표로 구분해서 나열할 수 있습니다.

함수가 호출되면 현재의 실행 흐름이 중단되고 호출된 함수로 넘어갑니다.
그 후, 인수가 매개변수에 순서대로 할당되고 함수 몸체에 문들이 실행되기 시작합니다.

## 매개변수와 인수 (Parameters and Argumments)

함수 외부에서 내부로 실행에 필요한 값을 전달해야 할 때, **매개변수**(**parameter**)라는 통로로 통해 **인수**(**argument**)를 전달합니다. 
인수는 값으로 평가될 수 있는 표현식이어야 하며, 함수를 호출할 때 개수와 타입에 제한 없이 지정할 수 있습니다.

```javascript
// x, y는 매개변수 (Parameter)
function add(x, y) {
  return x + y;
}

// 1, 2는 인수 (Argument)
var result = add(1, 2);
```
### 매개변수의 특징

- **초기화**: 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고, `undefined`로 초기화된 후 인수가 순서대로 할당됩니다.
- **스코프**(**Scope**): 매개변수는 함수 몸체 내에서만 참조할 수 있는 **지역 변수**입니다. 함수 외부에서는 참조할 수 없습니다.
```javascript
function add(x, y) {
  console.log(x, y); // 2 5
  return x + y;
}

add(2, 5);

// console.log(x, y); // ReferenceError: x is not defined
```

### 인수의 개수 불일치

자바스크립트 함수는 **매개변수의 개수와 인수의 개수가 일치하는지 확인하지 않습니다.**
- 인수가 매개변수보다 적으면, 할당받지 못하는 매개변수는 `undefined`값을 유지합니다.
- 인수가 매개변수보다 많으면, 초과된 인수는 무시됩니다.
```javascript
function add(x, y) {
  return x + y;
}

console.log(add(2)); // 2 + undefined => NaN
console.log(add(2, 5, 10)); // 10은 무시됨 => 7
```

초과된 인수는 그냥 버려지는 것은 아니고, 함수 내의 `arguments` 객체에 프로퍼티로 보관됩니다.

### 인수 확인 (Argument Vlidation)

자바스크립트의 유연한 특성 때문에, 함수를 정의할 때는 예기치 않은 상황에 대비해야 합니다.
```javascript
function add(x, y) {
  return x + y;
}

// 숫자가 아니어도 오류 없이 실행됨
console.log(add('a', 'b')); // 'ab'

// 인수가 부족해도 오류 없이 실행됨
console.log(add(2)); // NaN
```
이런 상황이 발생하는 이유는 다음과 같습니다.
1. 자바스크립트 함수는 **매개변수와 인수의 개수가 일치하는지 확인하지 않습니다.**
2. 자바스크립트는 **동적 타입 언어**이므로, 매개변수의 타입을 사전에 지정할 수 없다.

따라서 안정적인 코드를 위해 함수 내부에서 적절한 인수가 전달되었는지 확인할 필요가 있습니다.

### 타입 확인

`typeof` 연산자를 사용해 인수의 타입을 확인하고, 조건에 맞지 않으면 에러를 발생시켜 실행을 중단시킬 수 있습니다.
```javascript
function add(x, y) {
  if (typeof x !== 'number' || typeof y !== 'number') {
    // 타입이 맞지 않으면 TypeError를 발생시킴
    throw new TypeError('인수는 모두 숫자 값이어야 합니다.');
  }
  return x + y;
}

// console.log(add(2)); // TypeError 발생
// console.log(add('a', 'b')); // TypeError 발생
```
이러한 방어 코드는 런타임에 에러를 방지해주며, TypeScript와 같은 정적 타입 언어를 사용하면 컴파일 단계에서 이런 문제를 해결할 수 있습니다.


### 기본값 설정

인수가 전달되지 않았을 경우를 대비해 매개변수에 기본값을 설정할 수 있습니다.
- ES5 방식(단축 평가)
```javascript
function add(a, b, c) {
  a = a || 0;
  b = b || 0;
  c = c || 0;
  return a + b + c;
}
```

- ES6 방식(매개변수 기본값)
```javascript
function add(a = 0, b = 0, c = 0) {
  return a + b + c;
}

console.log(add(1, 2, 3)); // 6
console.log(add(1, 2));    // 3
console.log(add(1));       // 1
console.log(add());        // 0
```


## 매개변수의 최대 개수

ECMAScript 사양에는 매개변수의 최대 개수에 대해 명시적으로 제한은 없지만,
코드의 가독성과 유지보수를 위해 **매개변수의 개수는 적을수록 좋습니다.**

매개변수가 많아지만 함수를 호출할 때 전달해야 할 인수의 순서를 정확히 기억하기 어렵고, 실수가 발생할 확률이 높아집니다.
이상적으로 **매개변수는 3개 이하**를 사용하는 것이 권장됩니다.

만약 3개를 초과하는 매개변수가 필요하다면, **객체를 인수로 전달하는 방식**을 고려하는 것이 좋습니다.
```javascript
// jQuery의 ajax 함수 예시
$.ajax({
  method: 'POST',
  url: '/user',
  data: { id: 1, name: 'Lee' },
  cache: false
});
```
객체를 인수로 사용하면 다음과 같은 장점이 있습니다.
- 프로퍼티 키를 통해 각 인수의 의미를 명확히 알 수 있어 **가독성이 향상됩니다.**
- 매개변수의 **순서를 신경 쓰지 않아도 됩니다.**
- 실수를 줄이는 효과가 있습니다.

단, 주의할 점은 함수 내부에서 전달받은 객체의 상태를 변경하면 함수 외부의 원본 객체도 함께 변경되는 **부수 효과**(**side effect**)가 발생할 수 있다는 것입니다.

## 반환문 (Return Statement)

함수는 `return` 키워드와 표현식으로 구성된 **반환문**을 사용해 실행 결과를 함수 외부로 반환할 수 있습니다.
```javascript
function multiply(x, y) {
  return x * y; // 반환문
}

// 함수 호출은 표현식이며, 반환값으로 평가된다.
var result = multiply(3, 5);
console.log(result); // 15
```

### 반환문의 역할

반환문은 두 가지 핵심 역할을 합니다.
1. **함수 실행을 중단**: `return`문이 실행되면 함수의 실행을 즉시 중단하고 함수 몸체를 빠져나갑니다. `return`문 뒤에 다른 코드가 있더라도 실행되지 않습니다.
2. **값 반환**: `return`키워드 뒤에 오는 표현식을 평가한 값을 반환합니다. 만약 반환할 값이 명시되지 않거나 `return`문 자체가 생략되면, 함수는 암묵적으로 `undefined`를 반환합니다.
```javascript
function multiply(x, y) {
  return x * y;
  console.log('이 코드는 실행되지 않습니다.'); // 무시됨
}

function bar() {
  return; // 값을 명시하지 않았으므로 undefined 반환
}

function foo() {
  // return 문이 없으므로 undefined 반환
}

console.log(multiply(3, 5)); // 15
console.log(bar()); // undefined
console.log(foo()); // undefined
```

### 알아두면 좋은 `return`의 동작 방식

- **세미콜론 자동 삽입**(**ASI**): `return` 키워드 바로 뒤에서 줄바꿈을 하면 자바스크립트의 세미콜론 자동 삽입 기능이 동작하여 `return;`으로 해석될 수 있습니다.
이 경우 의도치 않게 `undefined`가 반환될 수 있으므로, 반환할 값은 `return`키워드와 같은 줄에 작성해야 합니다.
- **전역 스코프**: `return`문은 반드시 함수 몸체 내에서 사용되어야 합니다. 브라우저 환경의 전역 스코프에서 `return`을 사용하면 `SyntaxError`가 발생합니다.
- **Node.js**: Node.js 환경에서는 각 파일이 하나의 독립된 모듈로 동작하며, 내부적으로는 함수로 감싸여 있습니다(Module Wrapper Function).
이 때문에 파일의 최상단에서 `return`을 사용해도 에러가 발생하지 않습니다.

