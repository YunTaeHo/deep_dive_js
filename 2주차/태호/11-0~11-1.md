## 자바스크립트의 데이터 타입


자바스크립트가 제공하는 7가지 데이터 타입(숫자, 문자열, 불리언, null, undefined, 심볼, 객체 타입)은 크게 **원시 타입**(**Primitive type**)과 **객체 타입**(**Object type**)으로 구분할 수 있습니다.
이렇게 구분하는 핵심적인 이유는 두 타입이 메모리에 저장되고 전달되는 방식이 근본적으로 다르기 때문입니다.
- **불변성**: 원시 타입의 값은 **변경 불가능**(**immutable**)하지만, 객체 타입의 값은 **변경 가능**(**mutable**)합니다.
- **저장 방식**: 변수에 원시 값을 할당하는 변수에는 **실제 값**이 저장되고, 객체를 할당하면 **참조 값**(**메모리 주소**)이 저장됩니다.
- **전달 방식**: 원시 값을 다른 변수에 할당하면 값이 복사되어 전달되는 **'값에 의한 전달'** 이 일어나고, 객체를 전달하면 참조 값이 복사되는 **'참조에 의한 전달'** 이 일어납니다.
 
## 변경 불가능한 값(Imuutability)


원시 타입의 값은 변경 불가능한 값입니다. 한 번 생성된 원시 값은 읽기 전용(read-only)으로 메모리에서 직접 수정할 수 없습니다.

변수는 값을 식별하기 위한 이름일 뿐이며, 언제든지 다른 값을 재할당받을 수 있습니다.
원시 값을 재할당하는 과정은 값을 수정하는 것이 아니라, 새로운 값을 위한 메모리 공간을 확보하고 변수가 그 새로운 공간을 가리키도록 변경하는 것입니다.

예를 들어, 변수 `num`에 10을 할당했다가 20으로 재할당한다면:
1. 메모리에 숫자 값 `10`이 생성되고, 변수 `num`은 이 메모리 공간의 주소를 가리킵니다.
2. `num = 20` 코드가 실행되면, 메모리에 **새로운** 숫자 값 `20`이 생성됩니다.
3. 변수 `num`이 가리키던 주소는 `10`이 있던 곳에서 `20`이 새로 생성된 곳으로 변경됩니다. 기존의 `10`은 수정되지 않습니다.

이처럼 값이 직접 변경되지 않는 특성을 **불변성**(**Immutability**)이라고 합니다.
불변성은 데이터의 신뢰성을 보장하는 중요한 특징입니다. 만약 값이 마음대로 변경될 수 있다면, 상태 변화를 추적하기 어려워지고 예기치 않은 오류가 발생할 수 있습니다.


### 문자열과 불변성

원시 값을 메모리에 저장하려면 그 크기가 정해져 있어야 합니다.
ECMAScript 사양은 **숫자 타입은 8바이트, 문자열은 한 문자당 2바이트**로 규정하지만, 다른 원시 타입의 크기는 명확히 정의하지 않아 브라우저마다 구현이 다를 수 있습니다.

여기서 원시 값인 **문자열은 다른 원시 값과 조금 다른 특징**을 보입니다.
- 숫자: `1`이든 `100000`이든 상관없이 동일하게 **8바이트**의 메모리 공간을 차지합니다.
- **문자열**: 길이에 따라 메모리 공간의 크기가 달라집니다. 'A'는 2바이트, 'Hello'는 10바이트(5 * 2)의 공간을 차지합니다.

이처럼 메모리 할당 방식에 차이가 있지만, 가장 중요한 사실은 **문자열 역시 변경 불가능한 원시 값**이라는 점입니다.
```javascript
var str = 'Hello';
str = 'World';
```

위 코드에서 `str`의 값이 'Hello'에서 'World'로 바뀐 것처럼 보이지만, 실제로는 'Hello' 문자열을 수정한 것이 아닙니다.
메모리에 'World'라는 새로운 문자열이 생성되고, 변수 `str`이 그것을 새로 가리키게 된 것입니다.

문자열은 배열처럼 각 문자에 인덱스로 접근할 수 있는 유사 배열 객체입니다. 
하지만 그렇다고 해서 배열처럼 특정 문자를 수정할 수는 없습니다.
```javascript
var str = 'Hello';

console.log(str[0]); // 'H'

// str[0] = 'S'; // 에러가 발생하지는 않지만, 무시됩니다.
console.log(str); // 여전히 'Hello' 입니다. 값이 변경되지 않습니다.
```
이처럼 이미 생성된 문자열의 일부를 바꾸는 시도를 불가능하며, 이는 원시 값의 불변성 때문입니다.


## 값에 의한 전달 (Pass by Value)

'값에 의한 전달'은 한 변수에 할당된 원시 값을 다른 변수에 할당할 때 어떤 일이 일어나는지를 설명하는 개념입니다.

```javascript
var score = 80;
var copy = score; // '값에 의한 전달' 발생

console.log(score); // 80
console.log(copy);  // 80

score = 100; // score 변수에 새로운 값을 재할당

console.log(score); // 100
console.log(copy);  // 80 (score의 변경에 영향을 받지 않음)
```
`copy = score;`가 실행될 때, `copy` 변수는, `score` 변수의 **값**(**80**)**을 복사**하여 새로운 메모리 공간에 저장합니다.
따라서 `score`와 `copy`는 같은 값 `80`을 갖지만, 서로 다른 메모리 공간에 저장된 **별개의 값**이 됩니다.

그 결과 `score`의 값을 `100`으로 재할당해도 `copy`의 값에는 아무런 영향을 주지 않는다.

### '값에 의한 전달'의 정확한 의미

사실 '값에 의한 전달'이라는 용어는 엄밀히 말해 "값이 복사된다"기보다는 **"값이 저장된 메모리 주소가 전달되어, 변수가 그 주소를 통해 값을 참조한다"** 고 이해하는 것이 더 정확합니다.


자바스크립트 엔진의 메모리 관리에 대한 내부 동작은 명확히 정의되어 있지 않다.
따라서 엔진을 구현하는 제조사에 따라 미묘한 차이가 있을 수 있다.


`var copy = score;`가 실행될 때, 자바스크립트 엔진은 두 가지 방식으로 동작할 수 있습니다. 이 동작은 구현하는 제조사마다 다를 수 있습니다.
1. 값 `80`을 위한 **새로운 메모리 공간을 확보**하고 그 주소를 `copy`에 전달하는 방식
2. 일단은 `score`가 가리키는 **메모리 주소를 그대로 전달**했다가, 둘 중 하나의 변수에 재할당이 일어날 때 새로운 메모리 공간을 할당하는 방식(Python 등에서 사용).

어떤 방식을 사용하든 개발자에게 중요한 핵심은 동일합니다.
**두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값으로 취급되므로, 어느 한족의 재할당이 다른 쪽에 영향을 미치지 않는다**는 것입니다.