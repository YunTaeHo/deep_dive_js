

## 객체란?

객체는 **여러 값**(**프로퍼티**)**을 하나의 단위로 묶은 복합적인 자료구조**입니다. 
원시 값과는 근본적으로 다른 방식으로 동작하도록 설계되었습니다.
- **동적인 크기**: 겍체는 프로퍼티의 개수가 정해져 있지 않으며, 코드 실행 중에 동적으로 추가되거나 삭제될 수 있습니다. 이 대문에 원시 값처럼 메모리 공간의 크기를 사전에 정할 수 없습니다.
- **높은 비용**: 원시 값에 비해 객체를 생성하고 프로퍼티에 접근하는 것은 더 많은 비용이 드는 작업입니다. 객체의 크기가 커질수록 이 비용은 증가합니다.

이러한 특성 때문에 자바스크립트 엔진은 객체를 효율적으로 관리하기 위한 특별한 방식을 사용합니다.


### 자바스크립트 객체의 관리 방식(히든 클래스)

자바스크립트 객체는 Key-Value 쌍으로 이루어져 있어 해시 테이블과 유사해 보이지만, V8 엔진(Chrome, Node.js)과 같은 최신 자바스크립트 엔진들은 성능 최적화를 위해 **히든 클래스**(**Hidden Class**) 또는 **Shape**라는 방식을 사용합니다.

단순한 해시 테이블은 프로퍼티에 접근할 때마다 문자열 키를 기반으로 한 느린 탐색 과정이 필요합니다. 특히 작은 객체가 많은 경우 이는 큰 오버헤드가 됩니다.

**히든 클래스**는 이 문제를 해결하기 위해 도입되었습니다.
1. **객체 구조의 분류**: 엔진은 같은 프로퍼티 이름과 순서를 가친 객체들을 같은 히든 클래스로 묶습니다. 이 히든 클래스는 객체의 '모양(Shape)'에 대한 정보를 담고 있습니다.
2. **프로퍼티 오프셋(Offset) 저장**: 히든 클래스는 각 프로퍼티가 메모리상에서 얼머나 떨어져 있는지(오프셋)을 저장합니다.
3. **빠른 접근**: 한번 히든 클래스가 결정되면, 엔진은 해시 테이블처럼 키를 찾는 대신 C++처럼 고정된 오프셋을 이용해 프로퍼티 값에 매우 빠르게 접근할 수 있습니다.
```javascript
const obj1 = { x: 1, y: 2 }; // 히든 클래스 C0 생성
const obj2 = { x: 3, y: 4 }; // obj1과 구조가 같으므로 C0 재사용
```

만약 객체의 구조가 변경되면 (예: 프로퍼티 추가), 엔진은 새로운 히든 클래스를 생성하고 이를 연결하는 '전환(Transition)' 과정을 거칩니다.
이 방식 덕분에 동적인 자바스크립트 객체가 정적인 클래스 기반 언어와 유사한 수준의 성능을 낼 수 있습니다.

#### 더 알아보기

V8 엔진의 히든 클래스 동작 ㅂ아식에 대한 자세한 내용은 링크에서 확인할 수 있습니다.
https://v8.dev/blog/fast-properties


## 변경 가능한 값(Mutable Value)

객체 타입의 가장 큰 특징은 **값이 변경 가능하다**는 점입니다.
```javascript
ver person = {
  name: 'Lee'
}
```

변수에 원시 값을 할당하면 변수 자체가 값을 갖지만, 객체를 할당하면 변수는 **참조 값**(**Reference**)을 갖게 됩니다.
이 참조 값은 객체가 실제로 저장된 메모리 공간의 주소를 가리킵니다.
- **원시 값을 할당한 변수**: 변수를 참조하면 메모리에 저장된 **원시 값 자체**에 접근합니다.
- **객체를 할당한 변수**: 변수를 참조하면 메모리에 저장된 **참조 값**을 통해 실체 객체에 접근합니다.

이러한 구조 때문에 객체는 변수에 값을 **재할당하지 않고도** 객체 내부의 프로퍼티를 직접 수정, 추가, 삭제할 수 있습니다.
```javascript
var person = {
  name: 'Lee'
};

// 객체를 재할당한 것이 아니라, 내부 프로퍼티 값을 변경
person.name = 'Kim';
person.age = 20;

console.log(person); // { name: 'Kim', age: 20 }
```

`'person'` 변수가 가리키는 메모리 주소는 바뀌지 않은 채, 그 주소에 있는 객체의 내용만 변경된 것입니다. 이는 매우 효율적인 방식입니다.
만약 객체가 3D 모델 데이터처럼 매우 크다면, 작은 수정 하나 때문에 전체를 복사하여 재할당하는 것은 엄청난 성능 저하를 유발할 것입니다.

### 참조 공유의 문제점

객체는 참조 값을 통해 여러 변수가 **하나의 객체를 공유**할 수 있기 때문에, 예기치 못한 부작용이 발생할 수 있습니다.
이 문제를 해결하기 위해 객체를 복사하는 방법인 **얕은 복사**와 **깊은 복사**를 이해해야 합니다.

#### 얕은 복사(Shallow Copy)

객체의 최상위 프로퍼티만 복사하는 방식입니다. 
만약 프로퍼티의 값이 원시 값이면 값 자체가 복사되지만, 값이 또 다른 객체라면 그 객체의 **참조 값**만 복사됩니다.
즉, 중첩된 객체는 여전히 원본과 공유됩니다.

스프레드 문법(`...`)이나 `Object.assign()`이 대표적인 얕은 복사 방법입니다.
```javascript
const original = {
  a: 1,
  b: { c: 2 }
};

const copy = { ...original }; // 얕은 복사

copy.a = 100; // 원본에 영향 없음
copy.b.c = 99; // 원본에도 영향 있음!

console.log(original.a);   // 1
console.log(original.b.c); // 99 (공유된 객체의 프로퍼티가 변경됨)
```

#### 깊은 복사(Deep Copy)

객체의 모든 프로퍼티를 재귀적을 복사하여, 원본과의 참조가 완전히 끊어진 새로운 객체를 만드는 방식입니다.

자바스크립트 표준에는 깊은 복사를 위한 내장 함수가 없지만, 다음과 같은 방법을 사용할 수 있습니다.
1. `JSON.parse(JSON.stringify(obj))`: 간단하지만 `함수`, `undefined 값, `Symbol` 등을 유싫하고 성능이 좋지 않은 단점이 있습니다.
2. **라이브러리 사용**: Lodash의 `_.cloneDeep()` 메서드를 사용하는 것이 가장 안정적이고 편리한 방법입니다.


## 참조에 의한 전달 (Pass by Reference)


여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이 바로 **'참조의 의한 전달'** 의 핵심입니다.
```javascript
var person = {
  name: 'Lee'
};

// 참조 값을 복사 (얕은 복사). person과 copy는 같은 객체를 가리킨다.
var copy = person;
```

`copy = person;` 코드는 객체 자체가 복사되는 것이 아니라, `person` 변수가 가진 **참조 값**(**메모리 주소**)**이 복사**되어 `copy` 변수에 저장되는 것입니다.

결과적으로 `person`과 `copy`는 **동일한 객체를 공유**하게 되므로, 어느 한족에서 객체를 변경하면 다른 한쪽에도 똑같이 반영됩니다.
```javascript
copy.name = 'Park';

// copy를 변경했지만 person도 변경됨
console.log(person.name); // 'Park'
```

### 용어에 대한 이해

ECMAScript 사용에는 '값에 의한 전달'이나 '참조에 의한 전달'이라는 용어가 등장하지 않습니다. 
이 용어들은 C와 같은 언어에서 유래했어, 자바스크립트의 동작 방식과 정확히 일치하지는 않습니다.

자바스크립트의 동작을 가장 정확하게 설명하는 용어는 **"공유에 의한 전달** (**Pass by sharing**)**"** 입니다.
- **원시 값**: 변수 간에 값을 전달할 때, 값의 복사본이 전달된다 (**값에 의한 전달**처럼 동작).
- **객체**: 변수 간에 값을 전달할 때, **참조 값의 복사본**이 전달된다 (**참조에 의한 전달**처럼 동작).

핵심은 자바스크립트에는 포인터가 없으며, 모든 값의 전달은 **값을 복사해서 전달**한다는 것입니다. 
그 값이 원시 값이냐, 아니면 메모리 주소를 가리키는 참조 값이냐의 차이일 뿐입니다.