## 타입 변환이란?

자바스크립트의 모든 값에는 **타입**이 있습니다. 개발을 하다 보면 이 값의 타입을 의도적으로 바꾸거나, 혹은 자바스크립트 엔진에 의해
저절로 바뀌는 경우를 마주하게 됩니다. 이 두 가지를 각각 **명시적 타입 변환**과 **암묵적 타입 변환**이라고 부릅니다.
```javascript
var x = 10;

// 명시적 타입 변환
// 숫자를 문자열로 타입 캐스팅한다.

var str = x.toString();
console.log(typeof str, str); // string 10

// x의 값은 변경되지 않는다(부수 효과 X)
console.log(typeof x, x); // number 10
```
```javascript
var x = 10;

// 암묵적 타입 변환
// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다.
var str = x + '';
console.log(typeof str, str); // string 10
```


이 둘의 가장 중요한 공통점은 기존 원시 값은 **변경되지 않는다**는 것입니다. 타입 변환은 기존 값을 바탕으로
새로운 타입의 값을 만들어 일시적으로 사용할 뿐, 원래 변수에 할당된 값을 직접 수정하지는 않습니다.

이러한 타입 변환의 원리를 정확히 이해해야 코드의 동작을 예측하고 잠재적인 버그를 줄일 수 있습니다.

## 암묵적 타입 변환 (Implicit Coercion)

암묵적 타입 변환은 개발자의 의도와는 상관없이 자바스크립트 엔진이 표현식을 평가하는 과정에서 문맥에 맞게 타입을 자동으로 바꾸는 것을 말합니다.
자바스크립트는 에러를 발생시키기보다 가급적 코드를 실행하려는 유연한 특성이 있어 이런 변환이 자주 일어납니다.
```javascript
// 피연산자가 모두 문장뎔 타입이여야 하는 문액
'10' + 2; // 102

5 * '10'; // 50

!0 // true
if (1) {} 
```

### 문자열 타입으로 변환

`+`연산자는 피연산자 중 하나라도 문자열이 있으면 다른 피연산자를 문자열로 변환하여 연결합니다. 템플릿 리터럴의 표현식 삽입도 평가 결과를 문자열로 변환합니다.

```javascript
// 숫자 + 문자열 -> 문자열 연결
1 + '2' // "12"

// 템플릿 리터럴
`1 + 1 = ${1 + 1}` // "1 + 1 = 2"

// 다양한 타입의 암묵적 문자열 변환
'Number: ' + 100 // "Number: 100"
'Boolean: ' + true // "Boolean: true"
'Null: ' + null // "Null: null"
'Undefined: ' + undefined // "Undefined: undefined"

// 심벌은 명시적으로 .toString() 이나 String() 을 사용해야 함
// 'Symbol: ' + Symbol('key') // TypeError: Cannot convert a Symbol value to a string

// 객체는 "[object Object]" 라는 기본 문자열로 변환됨
'Object: ' + { name: 'Kim' } // "Object: [object Object]"
```


### 숫자 타입으로 변환

산술 연산자(`-`, `*`, `/`, `%`)나 비교 연산자 (`>`, `<`, `>=`, `<=`)를 사용할 때, 피연산자들은 연산을 위해 숫자 타입으로 변홥됩니다.

```javascript
// 산술 연산
1 - '1'   // 0
1 * '10'  // 10
1 / 'one' // NaN (숫자로 변환할 수 없는 문자열)

// 비교 연산
'1' > 0   // true ( '1'이 숫자 1로 변환되어 비교)

// 단항 연산자(+)를 이용한 변환
+''         // 0
+'123'      // 123
+true       // 1
+false      // 0
+null       // 0
// +Symbol('key') // TypeError: Cannot convert a Symbol value to a number
+undefined  // NaN
+{}         // NaN
+[]         // 0
+[10]       // 10
```

빈 문자열(`''`), 빈 배열(`[]`), `null`, `false`는 **0**으로, `true`는 **1**로 변환됩니다.
`undefined`나 대부분의 객체는 숫자로 변환할 수 없어 **NaN**(Not-a-Number)이 됩니다.


### 불리언 타입으로 변환

`if`문, `for`문, `while`문의 조건식처럼 불리언 값이 필요한 곳에서 타입이 자동으로 변환됩니다.
이 때 자바스크립트는 **Truthy**(**참 같은 값**)와 **Falsy**(**거짓 같은 값**로 값을 구분합니다.

**Falsy**값은 아래 6가지뿐이며, 이 외의 모든 값은**Truthy**로 평가됩니다.
- false
- undefined
- null
- 0, -0
- NaN
- 빈 문자열
```javascript
// Falsy 값 예시
if (undefined) { console.log('실행되지 않음'); }
if (null) { console.log('실행되지 않음'); }
if (0) { console.log('실행되지 않음'); }
if (NaN) { console.log('실행되지 않음'); }
if ('') { console.log('실행되지 않음'); }

// Truthy 값 예시
if (true) { console.log('실행됨'); }
if (1) { console.log('실행됨'); } // 0이 아닌 모든 숫자
if ('hello') { console.log('실행됨'); } // 비어있지 않은 모든 문자열
if ({}) { console.log('실행됨'); } // 빈 객체
if ([]) { console.log('실행됨'); } // 빈 배열
```

## 명시적 타입 변환

명시적 타입 변환은 개발자가 코드에 직접 타입을 바꾸겠다는 의도를 명확히 나타내는 것입니다. 표준 빌트인 생성 함수(`String`, `Number`, `Boolean`), 빌트인 메서드, 또는 연산자를 활용할 수 있습니다.


### 문자열 타입으로 변환

문자열 타입이 아닌 값을 문자열로 변환하는 방법은 다음과 같습니다.
1. `String()` 생성자 함수를 호출하는 방법
2. `Object.prototype.toString` 메서드를 사용하는 방법
3. 문자열 연결 연산자(`+`)를 이용하는 방법
```javascript
// 1. String() 함수
String(1);        // "1"
String(NaN);      // "NaN"
String(true);     // "true"

// 2. .toString() 메서드
(1).toString();   // "1"
(true).toString(); // "true"
// null과 undefined는 .toString() 메서드가 없어 에러 발생

// 3. 문자열 연결 연산자
1 + '';           // "1"
true + '';        // "true"
```

### 숫자 타입으로 변환

숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법은 다음과 같습니다.
1. `Number()` 생성자 함수 호출하는 방법
2. `parseInt()`, `parseFloat()` 함수를 사용하는 방법(문자열 전용)
3. `+`단항 산술 연산자를 이용하는 방법
4. `*`산술 연산자를 이용하는 방법

```javascript
// 1. Number() 함수
Number('123.45'); // 123.45
Number(true);     // 1
Number(false);    // 0

// 2. parseInt(), parseFloat() 함수
parseInt('123.45');    // 123 (정수 부분만 추출)
parseFloat('123.45');  // 123.45 (실수까지 추출)
parseInt('100px');     // 100 (숫자로 시작하는 부분만 인식)

// 3. + 단항 연산자
+'123.45'; // 123.45
+true;     // 1

// 4. * 산술 연산자
'123.45' * 1; // 123.45
true * 1;     // 1
```

### 불리언 타입으로 변환

불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법은 다음과 같습니다.
1. `Boolean()` 생성자 함수를 호출하는 방법
2. `!`(부정 논리) 연산자를 두번 사용하는 방법

```javascript
// 1. Boolean() 함수
Boolean('x');     // true
Boolean('');      // false
Boolean('false'); // true
Boolean(0);       // false
Boolean(1);       // true
Boolean({});      // true
Boolean([]);      // true

// 2. !! 연산자
!!'x';       // true
!!'';        // false
!!0;         // false
!!null;      // false
!!undefined; // false
!!{};        // true
```

코드를 예측 가능하게 만들려면 타입 변환의 원리를 이해하는 것은 필수적입니다. 모든 곳에서 명시적 변환을 고집합 필요는 없습니다.
`10 + ''`처럼 누구나 쉽게 이해할 수 있는 코드는 암묵적 변환을 활용하는 것이 더 간결하고 효율적일 수 있습니다.
중요한 것은 **팀과 자신이 코드의 동작을 명확하게 예측하고 제어할 수 있는가**입니다.