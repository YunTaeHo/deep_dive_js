# 🏛️ 프론트엔드 개발자 역량 로드맵 (메타인지 시스템 적용)
학습의 효율을 위해, 제가 가장 합리적이라고 생각하는 순서로 '대'분류를 재배치했습니다.

## 대(大) 1: HTML/CSS 기초 (The Visual Foundation)
모든 웹 페이지의 뼈대와 디자인입니다. 이 기반이 튼튼해야 그 위에 견고한 애플리케이션을 올릴 수 있습니다.

### 중(中): 시맨틱 HTML과 웹 접근성
* 소(小): 시맨틱 태그(`<main>`, `<nav>`, `<section>` 등)를 사용해야 하는 이유를 SEO와 웹 접근성 관점에서 설명하기
* 소(小): alt 속성, role 속성, aria-label 등 웹 접근성을 위한 기본 속성들의 용도 설명하기
* 소(小): <form> 태그와 <input>의 label을 for와 id로 연결하는 이유 설명하기

### 중(中): CSS 기본기와 Box Model
* 소(小): CSS 선택자(selector)의 우선순위가 어떻게 결정되는지 설명하기 (Specificity)
* 소(小): Box Model(content, padding, border, margin)을 그림으로 그리고 설명하기
* 소(小): box-sizing: border-box; 속성이 왜 'CSS 초기화'에 거의 필수로 사용되는지 설명하기

### 중(中): 모던 CSS 레이아웃
* 소(小): Flexbox의 justify-content와 align-items 속성을 이용해 아이템들을 정렬하는 다양한 예제 만들기
* 소(小): Grid의 grid-template-columns와 grid-template-rows를 이용해 복잡한 2차원 레이아웃 구성하기
* 소(小): position 속성(static, relative, absolute, fixed, sticky)들의 차이점과 각각의 사용 사례 설명하기

## 대(大) 2: JavaScript (The Core Logic)
웹에 생명을 불어넣는 언어. 이 파트의 깊이가 곧 개발자의 깊이를 결정합니다.

### 중(中): 기본 문법과 데이터 타입
* 소(小): 원시 타입과 참조 타입의 차이를 '메모리 할당' 관점에서 설명하기
* 소(小): == 대신 ===를 사용해야 하는 이유를 '타입 강제 변환'과 연관지어 설명하기
* 소(小): let, const가 var와 다른 점(스코프, 호이스팅)을 코드 예제로 증명하기

### 중(中): 함수 (Function)
* 소(小): 함수 선언문과 함수 표현식의 차이점(특히 호이스팅) 설명하기
* 소(小): 일반 함수와 화살표 함수의 this 바인딩 차이를 '호출 시점'과 '선언 시점'으로 설명하기
* 소(小): 클로저(Closure)를 이용해 외부에서 접근 불가능한 private 변수를 갖는 모듈 패턴 구현하기
* 소(小): map, filter, reduce 등 배열 고차 함수를 이용해 for문 없이 데이터 가공하기

### 중(中): 프로토타입과 클래스
* 소(小): 프로토타입 체인(Prototype Chain)이 어떻게 동작하는지 그림으로 설명하기
* 소(小): class 문법이 사실은 프로토타입 기반의 'Syntactic Sugar'임을 설명하기
* 소(小): new 연산자 없이 생성자 함수를 호출했을 때 발생하는 문제점 설명하기

### 중(中): 실행 컨텍스트와 비동기
* 소(小): 실행 컨텍스트가 생성되고 콜 스택에 쌓이는 과정을 상세히 설명하기
* 소(小): 이벤트 루프, 콜 스택, 태스크 큐(마이크로/매크로)의 상호작용을 그림으로 설명하기
* 소(小): Promise의 세 가지 상태(pending, fulfilled, rejected)와 async/await와의 관계 설명하기

## 대(大) 3: 자료구조 / 알고리즘 (Problem Solving Foundation)
효율적인 코드를 작성하고, 복잡한 문제를 논리적으로 해결하는 힘을 기릅니다. (모든 구현은 JS로)

### 중(中): 기본 자료구조
* 소(小): 스택(Stack)과 큐(Queue)의 차이점(LIFO/FIFO)을 설명하고 각각 배열로 구현하기
* 소(小): 해시 테이블(JS의 Map, Object)의 시간 복잡도가 평균적으로 O(1)인 이유 설명하기
* 소(小): 연결 리스트(Linked List)와 배열의 장단점 비교하기 (데이터 추가/삭제, 탐색 관점에서)

### 중(中): 알고리즘 기초
* 소(小): 시간 복잡도(Big-O)의 개념과 O(1), O(log n), O(n), O(n^2)의 성능 차이 설명하기
* 소(小): 완전 탐색(Brute-force)과 이진 탐색(Binary Search)의 접근 방식 차이 설명하기
* 소(小): 재귀(Recursion) 함수의 기본 구조(Base case, Recursive case)와 스택 오버플로우의 위험성 설명하기

## 대(大) 4: React (The UI Library)
현대 프론트엔드 개발의 표준. 컴포넌트 기반으로 복잡한 UI를 효율적으로 만듭니다.

### 중(中): React 기본 개념과 주요 Hooks
* 소(小): 가상돔(Virtual DOM)이 왜 필요한지, 어떻게 동작하는지 설명하기 (Diffing 알고리즘)
* 소(小): props와 state의 차이점, 데이터 흐름의 방향성(단방향) 설명하기
* 소(小): useState와 useEffect를 이용해 API 데이터를 fetching하고 화면에 렌더링하는 컴포넌트 만들기
* 소(小): useCallback, useMemo, React.memo를 사용한 렌더링 최적화의 원리와 사용 사례 설명하기

### 중(中): 상태 관리와 라우팅
* 소(小): Context API를 이용해 Props Drilling 없이 전역 상태 관리하기
* 소(小): (심화) Redux Toolkit 또는 Zustand를 사용한 상태 관리 패턴 익히기
* 소(小): React Router를 이용해 여러 페이지를 가진 SPA(Single Page Application) 구성하기

## 대(大) 5: Next.js (The React Framework)
React를 기반으로 서버사이드 렌더링, 정적 사이트 생성 등 강력한 기능을 제공하는 풀스택 프레임워크입니다.

### 중(中): Next.js 핵심 개념
* 소(小): CSR, SSR, SSG, ISR 렌더링 방식의 차이점과 각각의 장단점, 사용 사례 설명하기
* 소(小): 파일 시스템 기반 라우팅(File-system based Routing)의 동작 방식 설명하기
* 소(小): getServerSideProps와 getStaticProps의 차이점을 '데이터 fetching 시점'으로 설명하기
* 소(小): API Routes를 이용해 간단한 백엔드 API 서버 기능 구현하기

## 대(大) 6: Three.js (The 3D Graphics Library)
웹에서 인터랙티브한 3D 그래픽을 구현하기 위한 전문 분야입니다. (흥미가 있다면 도전)

### 중(中): Three.js 기본 구성 요소
* 소(小): Scene, Camera, Renderer의 역할을 설명하고 기본 씬(Scene) 구성하기
* 소(小): Mesh가 Geometry(모양)와 Material(재질)로 구성됨을 이해하고 정육면체 만들기
* 소(小): requestAnimationFrame을 이용해 3D 객체를 계속해서 회전시키는 애니메이션 구현하기

## 대(大) 7: 개발 생태계 및 도구 (The Ecosystem)
프로그래밍 실력 외에, 개발자로서 협업하고 생산성을 높이는 데 필수적인 도구들입니다.

### 중(中): 버전 관리 (Git) & 타입 시스템 (TypeScript)
* 소(小): git-flow 또는 github-flow 브랜칭 전략의 차이점 설명하기
* 소(小): JavaScript 프로젝트를 TypeScript로 점진적으로 마이그레이션하는 방법 설명하기
* 소(小): TypeScript의 interface와 type의 차이점과 각각의 사용 사례 설명하기

### 중(中): 빌드 도구와 테스트
* 소(小): Vite, Webpack 같은 모듈 번들러가 왜 필요한지 설명하기
* 소(小): Jest와 React Testing Library를 이용해 간단한 컴포넌트 단위 테스트 코드 작성하기
