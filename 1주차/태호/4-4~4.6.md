## 변수 선언의 실행 시점과 변수 호이스팅

먼저 아래 코드를 보시죠. 변수를 선언하기 전에 호출했는데 과연 결과는 어떨까요?
```javascript
console.log(score); // undefined

var score;
```
상식적으로 에러가 발생할 것 같지만, 결과는 `undefined`가 출력됩니다.
그 이유는 자바스크립트 엔진이 코드를 한 줄씩 실행하기 전에, 먼저 코드 전체를 훑어보며 모든 **선언문**을 찾아내 맨 위로 끌어올리기 때문입니다.

이처럼 변수 선언문이 코드의 최상단으로 끌어올려 진 것처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅**(**Variable Hoisting**)이라고 합니다. hoisting은 '끌어올리기'라는 뜻을 가지고 있죠.🏃‍♂️

**핵심**: `var`, `let`, `const`, `function`, `class` 등 모든 선언문은 코드 실행 전(런타임 이전)에 먼저 처리됩니다.
따라서 변수가 코드의 어디에 선언되었든 상관없이 해당 스코프 내 어디서든 참조할 수 있습니다.

`let`이나 `const`는 호이스팅이 된다. 다만, 아직 초기화 되지 않아 접근할 수 없는 것이다.
해당 부분은 15.2절에서 자세히 다룬다.(TDZ)



## 선언과 할당의 실행 시점 차이


변수에 값을 할당(대입, 저장)할 때는 **할당 연산자 `=`**를 사용합니다.
할당 연산자는 우변의 값을 좌변의 변수에 할당하는 역할을 합니다.
```javascript
var score; // 변수 선언
score = 80; // 값의 할당

// 하나의 문으로 단축해서 사용할 수 있다
var score = 80; // 변수 선언과 값의 할당
```
문법적으로 두 가지 방식 모두 가능하지만, 여기서 중요한 점은 **어떤 방식을 사용하든 자바스크립트 엔진은 '선언'과 '할당'을 
별개의 작업으로 인식한다는 것**입니다. 왜냐하면 이 둘은 실행되는 시점이 다르기 때문입니다.
- **변수 선언**: 코드가 실행되기 전, 평가 단계에서 먼저 실행됩니다.(호이스팅 발생)
- **값의 할당**: 코드가 한 줄씩 순서대로 실행될 때(런타임) 실행됩니다.
따라서 `var score = 80;`이라는 한 줄의 코드는, 내부적으로 `var score;`가 먼저 처리되고(호이스팅),
이후 코드 실행 순서가 되었을 때 `score = 80;`이 실행되는 방식으로 동작합니다.


예제를 통해 `var`키워드의 **선언**과 **할당**의 실행 시점이 어떻게 다른지 명확히 살펴보겠습니다.

### 선언과 할당을 분리한 경우
```javascript
console.log(score); // (a) undefined

var score; // (1) 변수 선언
score = 80; // (2) 값의 할당

console.log(score); // (b) 80
```
- **코드 실행전**: (1)의 변수 선언문(`var: score;`)이 먼저 호이스팅되어, `score`라는 변수가 생성되고 `undefined`로 초기화됩니다.
- **코드 실행중**(**런타임**):
  - (a) `console.log(score)`가 실행됩니다. 아직 값 할당 전이므로 `undefined`가 출력됩니다.
  - (2) `score = 80;`이 실행됩니다. `score` 변수에 `80`이라는 값이 할당(정확히는 재할당)됩니다.
  - (b) `console.log(score)`가 실행됩니다. 이제 `score`는 `80`을 가리키므로 `80`이 출력됩니다.


### 선언과 할당을 한 줄에 작성한 경우
변수 선언과 값의 할당을 하나의 문으로 단축해도 앞 예제와 동일한 값을 내보낸다
```javascript
console.log(score); // (a) undefined

var score = 80; // (1) 변수 선언과 값의 할당

console.log(score); // (b) 80
```
이 코드는 한 줄로 작성되었지만, 자바스크립트 엔진은 **분리한 경우와 똑같은 방식**으로 처리합니다.
- **코드 실행전**: (1)의 `var: score;`부분만 먼저 호이스팅되어, `score`는 `undefined`로 초기화됩니다.
- **코드 실행중**(**런타임**):
  - (a) `console.log(score)`가 실행됩니다. 역시 `undefined`가 출력됩니다.
  - (1) 코드의 할당 부분인 `score = 80;`이 그 자리에 도달했을 때 실행됩니다.
  - (b) `console.log(score)`가 실행되어 최종 값인 `80`이 출력됩니다.

변수의 선언과 값의 할당을 한 줄로 단축해서 표현하더라도, 자바스크립트 엔진은 결국 **'선언부'와 '할당부'를 나누어 각각 다른 시점에 실행합니다.** 따라서 두 예제의 동작 방식과 결과는 완전 동일합니다. 이 원리를 이해하는 것이 호이스팅을 정확히 파악하는 핵심입니다.
<img width="495" height="268" alt="image" src="https://github.com/user-attachments/assets/ad2474b3-5e05-4037-9ca5-baa37a099120" />


## 값의 재할당

**재할당**이란 이미 값이 있는 변수에 새로운 값을 다시 할당하는 것을 말합니다. 
`var`키워드로 선언한 변수는 자유롭게 값을 재할당 할  수 있으며, 이 때문에 `변수(변할 수 있는 수)`라고 불립니다.
만약 재할당이 불가능 하다면 그것은 `상수(항상 같은 수)`입니다.
```javascript
var score = 80; // 변수 선언과 값의 할당 
score = 80; // 값의 재할당
```
여기서 중요한 점은 값을 재할당할 때의 메모리 동작 방식입니다.
1. `score = 80;`이 실행되면, 메모리에 `80`을 위한 공간이 생기고 `score`는 그 주소를 가리킵니다.
2. `score = 90;`dl 실행되면, 기존의 `80`을 지우는 것이 아니라 **새로운 메모리 공간을 확보**하여 `90`을 저장하고, `score`는 이제 새로운 주소를 가리킵니다.
<img width="648" height="254" alt="image" src="https://github.com/user-attachments/assets/01d9dff3-12d2-422b-a067-dcf5eb812ce2" />

이후 `80`은 더이상 아무도 참조하지 않는 불필요한 값이 됩니다.
이러한 값들은 **가비지 컬렉터**(**Garbage collector**)에 의해 자동으로 메모리에서 해제됩니다. 🧹


## 가비지 컬렉터란?

더 이상 사용되지 않는 메모리를 주기적으로 찾아내어 해제하는 기능입니다. 자바스크립트와 같이 가비지 컬렉터가 내장된 언어를 **매니지드 언어**(**Managed Language**)라고 하며, 개발자가 직접 메모리를 관리하지 않아도 되어 편리하지만 약간의 성능 손실을 감수해야 합니다.(C언어처럼 개발자가 직접 메모리를 할당하고 해제하는 언어는 **언매니지드 언어**라고 합니다.)
