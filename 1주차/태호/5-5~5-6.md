세미콜로과 세미콜론 자동 삽입 기능

세미콜론(;)은 문의 종료를 나타낸다. 
자바스크립트 엔진은 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다.
따라서 문을 끝낼 때는 세미콜론을 붙여야 한다.

단, 중괄호로 묶은 코드불록 if문, for문, 함수 등의 코드 블록 뒤에는 세미콜론을 붙이지 않는다.
이러한 코드 블록은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문이다.

문의 끝에 붙이는 세미콜론은 옵션이다. 생략 가능하다는 소리이다.
자바스크립트 엔진이 소스코드를 해석할 때 문의 끝을 예측해 자동으로 붙이는 기능인 세미콜론 자동 삽입 기능(ASI)이 암목적으로 수행되기 떄문이다.

하지만 세미콜론 자동 삽입 기능이 개발자의 예측에 벗어나는 경우가 간혹 있다.
정확히 말하면 개발자가 제대로 이해하지 못하고 활용한 것이다.
```javascript
function foo () {
  return
    {}
  // ASI의 동작 결과 => return; {};
  // 개발자의 예측 => return {};
}

console.log(foo()); // undefined

var bar = function () {}
(function() {})();
// ASI 동작 결과 => function () {} (function() {})(); 
// 개발자의 예측 => function () {}; (function() {})();
// TypeError: (ijntermediate value)(...) is not a function
```
세미콜론은 왠만하면 ESlint로 붙인다.
기본으로 설정되어 있고, TC39도 세미콜론 사용을 권장한다.

표현식인 문과 표현식이 아닌 문

표현식은 문의 일부일 수도 있고 그 자체로 문이 될 수도 있다. 다음 예제를 살펴보자.
```javascript
// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.
var x;

// 1, 2, 1 + 2, x = 1 + 2는 모두 표현식이다.
// x = 1 + 2는 표현식이면서 완전한 문이기도 하다.
x = 1 + 2;
```
표현식과 문을 구별하는 법은 의외로 간단하다. 구별하는 방법에 대해 살펴보자.
문에는 표현식인 문과 표현식이 아닌 문이 있다.
값으로 평가가 되냐 안되냐의 차이다.

표현식인 문과 표현식이 아닌 문은 간단하고 명료한 방법은 변수에 할당해 보는 것이다.
표현식인 문은 값으로 평가되므로 변수에 할당할 수 있다.
표현식이 아닌 문은 값으로 평가할 수 없으므로 변수에 할당하면 에러가 발생한다.
다음 예제를 살펴보자.
```javascript
// 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo = var x; // SyntaxError: Unexpected token var
```
위 예제의 변수 선언문은 표현식이 아닌문이다. 다시 말해 값으로 평가될 수 없다.
따라서 변수 선언문으 값처럼 사용할 수 없다.
```javascript
// 변수 선언문은 표현식이 아닌 문이다.
var x;

// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.
x = 100;
```
이에 반해 위 예제의 할당문 x = 100은 그 자체가 표현식이다.
즉, 할당문은 표현식인 문이기 때문에 값처럼 사용할 수 있다.
```javascript
// 표현식인 문은 값처럼 사용할 수 있다.
var foo = x = 100;
console.log(foo); // 100
```

할당문을 값처럼 변수에 할당했다.
표현식인 문인 할당문은 할당한 값으로 평가된다.
즉, x = 100 은 x 변수의 할당한 값 100으로 평가한다.
따라서 foo 변수에는 100이 할당된다.

크롬도구에서 표현식이 아닌 문은 undefined, 표현식인 문은 값으로 표현된다.
