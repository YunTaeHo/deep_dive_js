## `var` 키워드의 문제점

ES5까지 변수 선언은 `var`키워드만 가능했습니다. `var` 키워드는 독특한 특징으로 인해 여러 문제를 발생시킬 수 있습니다.

### 변수 중복 선언 허용

`var` 키워드로 선언한 변수는 중복 선언이 가능합니다. 이 경우 에러가 발생하지 않고, 초기화문의 유무에 따라 다르게 동작합니다.
```javascript
var x = 1;
var y = 1;

// x는 초기화문이 있으므로 var 키워드가 없는 것처럼 x = 100;으로 재할당됩니다.
var x = 100; 

// y는 초기화문이 없으므로 무시됩니다.
var y; 

console.log(x); // 100
console.log(y); // 1
```
이처럼 중복 선언이 허용되면, 의도치 않게 변수 값을 덮어쓸 가능성이 있어 예기치 못한 오류를 발생시킬 수 있습니다.


### 함수 레벨 스코프

`var` 키워드로 선언한 변수는 **오로지 함수의 코드 블록만을 지역 스코프로 인정**합니다.
따라서 함수 외부에서 `var` 키워드로 선언한 변수는 `if`, `for`문과 같은 코드 블록 내에서 선언해도 모두 전역 변수가 됩니다.
```javascript
var x = 1;

if (true) {
  // if 블록 내에서 선언했지만 전역 변수 x에 영향을 줍니다.
  var x = 10;
}
console.log(x); // 10


var i = 10;
// for 문의 변수 선언문에서 사용된 i도 전역 변수입니다.
for(var i = 0; i < 5; i++) {
  console.log(i); // 0, 1, 2, 3, 4
}

// for 문이 종료된 후에도 i의 값은 남아있습니다.
console.log(i); // 5
```
이러한 함수 레벨 스코프는 의도치 않게 전역 변수를 남용하게 만들어, 프로그램의 복잡성을 높이고 잠재적인 오류 발생 가능성을 키웁니다.

### 변수 호이스팅

`var` 키워드로 변수를 선언하면, 변수 선언문이 스코프의 최상단으로 끌어올려지는 **변수 호이스팅(Variable Hoisting)** 이 발생합니다.
이로 인해 변수 선언문 이전에 변수를 참조해도 에러가 발생하지 않고 `undefined`를 반환합니다.
```javascript
// 변수 선언문 이전에 참조했지만, 호이스팅으로 인해 undefined가 출력됩니다.
console.log(foo); // undefined

foo = 123;

console.log(foo); // 123

// 실제로는 이 선언문이 최상단으로 끌어올려진 것처럼 동작합니다.
var foo;
```
이는 코드의 실행 흐름을 예측하기 어렵게 만들고, 가독성을 떨어뜨리며 오류를 유발할 수 있습니다.

## `let` 키워드

`var` 키워드의 단점을 보완하기 위해 ES6에서 `let` 키워드가 도입되었습니다.

### 변수 중복 선언 금지
`let` 키워드는 동일한 이름의 변수를 중복해서 선언하는 것을 허용하지 않습니다.
중복 선언 시 문법 에러(SyntaxError)가 발생합니다.
```javascript
var foo = 123;
var foo = 456; // 문제 없음

let bar = 123;
// let bar = 456; // SyntaxError: Identifier 'bar' has already been declared
```

### 블록 레벨 스코프

`let` 키워드로 선언된 변수는 함수뿐만 아니라 `if`, `for`, `while`문 등 모든 코드 블록(`{...}`)을 지역 스코프로 인정하는 **블록 레벨 스코프**를 따릅니다.
```javascript
let foo = 1; // 전역 변수

{
  let foo = 2; // 지역 변수
  let bar = 3; // 지역 변수
}

console.log(foo); // 1 (전역 변수 foo를 참조)
// console.log(bar); // ReferenceError: bar is not defined (블록 외부에서 참조 불가)
```
블록 레벨 스코프는 변수의 생명 주기를 짧게 유지하여 전역 변수 오염 가능성을 줄이고 코드의 안정성을 높입니다.


### 변수 호이스팅

`let` 키워드로 선언한 변수도 호이스팅이 발생하지만, `var`와 다르게 동작합니다.
`var`는 선언과 동시에 `undefined`로 초기화되는 반면, `let`은 **선언 단계와 초기화 단계가 분리되어 진행**됩니다.
- **선언 단계**: 런타임 이전에 스코프에 변수 식별자를 등록합니다.
- **초기화 단계**: 실제 변수 선언문에 도달했을 때 실행됩니다.

스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간은 **일시적 사각지대(Temporal Dead Zone)** 라고 부르며, 이 구간에서 변수에 접근하면 참조 에러(ReferenceError)가 발생합니다.
```javascript
// TDZ에 있는 foo에 접근하여 참조 에러 발생
// console.log(foo); // ReferenceError: Cannot access 'foo' before initialization

let foo; // 초기화 단계
console.log(foo); // undefined (초기화되었지만 값은 할당되지 않음)

foo = 1; // 할당 단계
console.log(foo); // 1
```

호이스팅이 발생하지 않는 것처럼 보이는 이유는 이 TDZ 때문입니다.
`let` 변수도 호이스팅이 되기 때문에, 블록 내에서 선언된 변수는 블록 외부의 동일한 이름의 변수를 가립니다(shadowing).
```javascript
let foo = 1; // 전역 변수

{
  // 호이스팅으로 인해 이 블록의 foo는 지역 변수 foo로 인식됩니다.
  // 하지만 아직 초기화되지 않았기 때문에 TDZ에 해당하여 에러가 발생합니다.
  // console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
  let foo = 2; // 지역 변수
}
```


### 전역 객체와 `let`

`var` 키워드로 선언한 전역 변수는 전역 객체 `window`의 프로퍼티가 됩니다. window는 생략할 수 있습니다.
```javascript
var x = 1;
y = 2; // 암묵적 전역

console.log(window.x); // 1
console.log(window.y); // 2
```

하지만 `let` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아닙니다.
`let` 전역 변수는 전역 스코프의 선언적 환경 레코드(Declarative Evironment Record)라는 보이지 않는 개념적 블록에 존재하게 됩니다.
```javascript
let x = 1;

console.log(window.x); // undefined
console.log(x);        // 1
```