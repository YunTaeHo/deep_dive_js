## 함수 레벨 스코프 (Function-Level Scope)

자바스크립트에서 `var` 키워드는 **함수 레벨 스코프**를 따릅니다.
이는 **오직 함수 몸체 `{}` 만을 지역 스코프로 인정**한다는 의미입니다.

대부분의 다른 프로그래밍 언어(C, Java 등)는 `if`, `for`, `while`문과 같은 모든 코드 블록 `{}`이 자신만의 지역 스코프를 만드는데, 이를 **블록 레벨 스코프(Block-Level Scope)** 라고 합니다.

`var`는 이 규칙을 따르지 않기 때문에, 함수가 아닌 블록 내에서 선언된 변수는 지역 변수가 아니라 바깥 스코프(주로 전역)의 변수로 취급됩니다.
이로 인해 예기치 않은 결과가 발생할 수 있습니다.

- `if` 블록 예제
```javascript
var x = 1;

if (true) {
  var x = 10; // 이 x는 새로운 지역 변수가 아닌, 전역 변수 x를 가리킴
}

console.log(x); // 10
```
`if`문은 `var`에게 스코프를 만들어주지 못합니다.
따라서 `if` 블록 안의 `var x = 10;`은 새로운 변수를 선언하는 것이 아니라, 이미 존재하는 **전역 변수 `x`의 값을 10으로 재할당**하는 코드가 됩니다.

- `for` 블록 예제
```javascript
var i = 1;

for (var i = 0; i < 5; i++){
  console.log(i); // 0 1 2 3 4
}

console.log(i); // 5
```
`for`문 역시 `var`에게 스코프를 만들어주지 못합니다. 
따락서 반복을 위해 선언된 변수 `i`는 전역 변수가 됩니다.
반복문이 종료된 후 `i`의 값은 5가 되고, 이 값은 전역 스코프에 그대로 남아있게 됩니다.

### `let`과 `const`의 등장

`var`의 이러한 동작 방식은 직관적이지 않고 버그를 유발하기 쉽습니다.
이 때문에 ES6에서는 블록 레벨 스코프를 지원하는 `let`과 `const` 키워드가 도입되었으며, 현재는 `var`의 사용을 지양하는 것이 일반적입니다.


## 렉시컬 스코프 (Lexical Scope)

**렉시컬 스코프(Lexical Scope)** 또는 **정적 스코프(Static Scope)** 는 함수가 **어디서 호출**되었는지가 아니라 **어디서 정의**되었는지에 따라 상위 스코프를 결정하는 방식입니다.
자바스크립트는 렉시컬 스코프를 따릅니다.

아래 예제를 통해 살펴보겠습니다.
```javascript
var x = 1;

function foo() {
  var x = 10;
  bar(); // 2. bar 함수를 '호출'
}

function bar() { // 1. bar 함수를 전역에 '정의'
  console.log(x);
}

foo(); // 결과: 1
bar(); // 결과: 1
```
`bar` 함수는 `foo`함수 내부에서 **호출**되었지만, **정의**된 곳은 전역 스코프입니다.
- **렉시컬 스코프 규칙**: `bar` 함수의 상위 스코프는 **정의된 위치**인 **전역 스코프**로 정적으로 결정됩니다.
- **실행**: `bar` 함수가 실행되면, `console.log(x)`는 자신의 상위 스코프인 전역 스코프에서 `x`를 찾습니다.
- **결과**: 따라서 `foo` 함수 내부의 `var x = 10;`은 `bar`함수에 아무런 영향을 주지 못하며, 전역 변수인 `1`이 두 번 모두 출력됩니다.

이처럼 함수는 자신이 **생성(정의)되는 시점의 스코프를 기억**하고, 호출될 때마다 그 기억된 상위 스코프를 참조합니다.
함수의 호출 위치는 스코프 체인에 아무런 영향을 주지 않습니다.